#' Create Tuning Control Parameters
#'
#' This function creates a list of tuning parameters used by the pmmh function.
#'
#' @param pilot_proposal_sd Standard deviation for pilot proposals. Default is
#' 0.1.
#' @param pilot_n Number of pilot particles for particle filter. Default is 100.
#' @param pilot_m Number of iterations for MCMC. Default is 2000.
#' @param pilot_target_var The target variance for the posterior log-likelihood
#' evaluated at estimated posterior mean. Default is 1.
#' @param pilot_burn_in Number of burn-in iterations for MCMC. Default is 1000.
#' @param pilot_reps Number of times a particle filter is run. Default is 10.
#' @param pilot_algorithm The algorithm used for the pilot particle filter.
#' Default is "SISAR".
#' @param pilot_resample_fn The resampling function used for the pilot particle
#' filter. Default is "stratified".
#'
#' @return A list of tuning control parameters.
#' @export
tune_control <- function(pilot_proposal_sd = 0.1, pilot_n = 100, pilot_m = 2000,
                         pilot_target_var = 1, pilot_burn_in = 1000,
                         pilot_reps = 10,
                         pilot_algorithm = c("SISAR", "SISR", "SIS"),
                         pilot_resample_fn = c(
                           "stratified", "systematic",
                           "multinomial")
                         ) {
  if (!is.numeric(pilot_proposal_sd) || pilot_proposal_sd <= 0) {
    stop("pilot_proposal_sd must be a positive numeric value.")
  }
  if (!is.numeric(pilot_n) || pilot_n <= 0) {
    stop("pilot_n must be a positive numeric value.")
  }
  if (!is.numeric(pilot_m) || pilot_m <= 0) {
    stop("pilot_m must be a positive numeric value.")
  }
  if (!is.numeric(pilot_target_var) || pilot_target_var <= 0) {
    stop("pilot_target_var must be a positive numeric value.")
  }
  if (!is.numeric(pilot_burn_in) || pilot_burn_in <= 0) {
    stop("pilot_burn_in must be a positive numeric value.")
  }
  pilot_algorithm <- match.arg(pilot_algorithm)
  pilot_resample_fn <- match.arg(pilot_resample_fn)
  list(
    pilot_proposal_sd = pilot_proposal_sd,
    pilot_n = pilot_n,
    pilot_m = pilot_m,
    target_var = pilot_target_var,
    pilot_burn_in = pilot_burn_in,
    pilot_reps = pilot_reps,
    pilot_algorithm = pilot_algorithm,
    pilot_resample_fn = pilot_resample_fn
  )
}

#' Particle Marginal Metropolis-Hastings (PMMH) for State-Space Models
#'
#' This function implements a Particle Marginal Metropolis-Hastings (PMMH)
#' algorithm to perform Bayesian inference in state-space models. It first
#' runs a pilot chain to tune the proposal distribution and the number of
#' particles for the particle filter, and then runs the main PMMH chain.
#'
#' @param y A numeric vector of observations.
#' @param m An integer specifying the total number of MCMC iterations.
#' @param init_fn_ssm A function to initialize the state-space model.
#' @param transition_fn_ssm A function that defines the state transition of the
#' state-space model.
#' @param log_likelihood_fn_ssm A function that calculates the log-likelihood
#' for the state-space model given latent states.
#' @param log_priors A list of functions for computing the log-prior of each
#' parameter.
#' @param init_params A vector of initial parameter values.
#' @param burn_in An integer indicating the number of initial MCMC iterations
#' to discard as burn-in.
#' @param num_chains An integer specifying the number of PMMH chains to run.
#' @param algorithm A character string specifying the particle filtering
#' algorithm to use. Must be one of \code{"SISAR"}, \code{"SISR"}, or
#' \code{"SIS"}. Defaults to \code{"SISAR"}.
#' @param resample_fn A character string specifying the resampling method.
#' Must be one of \code{"stratified"}, \code{"systematic"}, or
#' \code{"multinomial"}. Defaults to \code{"stratified"}.
#' @param param_transform An optional character vector that specifies the
#' transformation applied to each parameter. Currently supports
#' \code{"log"} and \code{"identity"}. If \code{NULL}, the \code{"identity"}
#' transformation is used for all parameters.
#' @param tune_control A list generated by \code{\link{tune_control}} containing
#' tuning parameters for the pilot chain, such as \code{pilot_m},
#' \code{pilot_n}, \code{pilot_reps}, \code{pilot_proposal_sd},
#' \code{pilot_algorithm}, and \code{pilot_resample_fn}.
#' @param ... Additional arguments passed to the state-space model functions
#' and the particle filter.
#'
#' @details The PMMH algorithm proceeds in three main steps:
#' \enumerate{
#'   \item \strong{Pilot Chain:} A pilot particle chain is run using the
#'   settings provided in \code{tune_control} to obtain initial estimates for
#'   the parameter vector, its covariance, and the required number of particles.
#'   \item \strong{Main MCMC Chain:} The main PMMH chain is executed for
#'   \code{m} iterations using the tuned settings. The proposal step may
#'   apply a log or identity transformation to each parameter based on the
#'   \code{param_transform} argument.
#'   \item \strong{Post-Processing:} After discarding the burn-in samples,
#'   the latent state estimates from the remaining iterations are combined to
#'   compute a final latent state estimate as the column means of the latent
#'   state matrix.
#' }
#'
#' @return A list containing:
#' \describe{
#'   \item{\code{theta_chain}}{A matrix of post burn-in parameter samples.}
#'   \item{\code{loglike_chain}}{A numeric vector of post burn-in
#'   log-likelihood values.}
#'   \item{\code{latent_state_chain}}{A list of latent state estimates from
#'   each post burn-in iteration.}
#'   \item{\code{latent_state_estimate}}{A vector of the final latent state
#'   estimate, computed as the column means of the latent state matrix.}
#' }
#'
#' @examples
#' \dontrun{
#' # Define dummy functions for the state-space model:
#' init_fn <- function() stats::rnorm(1)
#' transition_fn <- function(x) x + stats::rnorm(1)
#' log_likelihood_fn <- function(x, y) dnorm(y, mean = x, log = TRUE)
#' log_prior <- function(param) dnorm(param, log = TRUE)
#'
#' # Generate some synthetic data:
#' y <- stats::rnorm(100)
#' m <- 1000
#' init_params <- 0
#' burn_in <- 100
#'
#' # Run the PMMH algorithm:
#' result <- pmmh(y, m, init_fn, transition_fn, log_likelihood_fn,
#'                log_priors = list(log_prior), init_params, burn_in)
#' }
#'
#' @export
pmmh <- function(y, m, init_fn_ssm,
                 transition_fn_ssm, log_likelihood_fn_ssm,
                 log_priors, init_params, burn_in,
                 num_chains = 4,
                 algorithm = c("SISAR", "SISR", "SIS"),
                 resample_fn = c("stratified", "systematic", "multinomial"),
                 param_transform = NULL,
                 tune_control = tune_control(),
                 ...) {
  # Validate inputs:
  if (!is.numeric(y)) {
    stop("y must be a numeric vector")
  }
  if (!is.numeric(m) || m <= 0) {
    stop("m must be a positive integer")
  }
  if (!is.numeric(burn_in) || burn_in <= 0) {
    stop("burn_in must be a positive integer")
  }
  if (burn_in >= m) {
    stop("burn_in must be smaller than the number of MCMC iterations (m)")
  }
  if (!is.numeric(num_chains) || num_chains <= 0) {
    stop("num_chains must be a positive integer")
  }
  algorithm <- match.arg(algorithm)
  resample_fn <- match.arg(resample_fn)
  # Check if the param_transform argument is valid
  if (!is.null(param_transform)) {
    invalid_transform <- which(!(param_transform %in% c("log", "identity")))
    if (length(invalid_transform) > 0) {
      warning("Currently only supports 'log' and 'identity' transformation.
              Using 'identity' (no transformation) instead.")
      param_transform[invalid_transform] <- "identity"
    }
  }

  # ---------------------------
  # Step 1: Run the pilot (particle) chain using tune_control() settings.
  # ---------------------------
  pilot_chain <- .run_pilot_chain(
    y = y,
    pilot_m = tune_control$pilot_m,
    pilot_n = tune_control$pilot_n,
    pilot_reps = tune_control$pilot_reps,
    init_fn_ssm = init_fn_ssm,
    transition_fn_ssm = transition_fn_ssm,
    log_likelihood_fn_ssm = log_likelihood_fn_ssm,
    log_priors = log_priors,
    proposal_sd = tune_control$pilot_proposal_sd,
    init_params = init_params,
    algorithm = tune_control$pilot_algorithm,
    resample_fn = tune_control$pilot_resample_fn,
    param_transform = param_transform,
    ...
  )

  # Use pilot chain estimates:
  init_theta <- pilot_chain$pilot_theta_mean
  proposal_cov <- pilot_chain$pilot_theta_cov
  target_n <- pilot_chain$target_n

  # If no transform is provided, default to identity for all parameters.
  if (is.null(param_transform)) {
    param_transform <- rep("identity", length(init_theta))
  }

  # ---------------------------
  # Step 2: Run the PMMH chains (m iterations) using the tuned settings.
  # ---------------------------
  cat("Running particle MCMC chains with tuned settings...\n")

  # Set up storage for chains: each chain will have its own theta, loglike,
  # and state estimates.
  theta_chains <- vector("list", num_chains)
  loglike_chains <- vector("list", num_chains)
  state_est_chains <- vector("list", num_chains)

  for(chain in 1:num_chains) {
    # Initialize for each chain using the pilot chain estimate:
    current_theta <- init_theta
    # Set up storage for this chain:
    theta_chain <- matrix(NA, nrow = m, ncol = length(current_theta))
    colnames(theta_chain) <- names(current_theta)
    loglike_chain <- numeric(m)
    state_est_chain <- vector("list", m)

    # Evaluate particle filter at the initial parameter value.
    pf_result <- do.call(particle_filter, c(
      list(
        y = y,
        n = target_n,
        init_fn = init_fn_ssm,
        transition_fn = transition_fn_ssm,
        log_likelihood_fn = log_likelihood_fn_ssm,
        algorithm = algorithm,
        resample_fn = resample_fn
      ),
      as.list(current_theta),
      list(...)
    ))
    current_loglike <- pf_result$loglike
    current_state_est <- pf_result$state_est

    theta_chain[1, ] <- current_theta
    loglike_chain[1] <- current_loglike
    state_est_chain[[1]] <- current_state_est

    if (all(param_transform == "identity")) {
      for (i in 2:m) {
        proposed_theta <- MASS::mvrnorm(n = 1, mu = current_theta,
                                        Sigma = proposal_cov)
        log_prior_proposed <- sapply(seq_along(proposed_theta), function(j) {
          log_priors[[j]](proposed_theta[j])
        })
        if (any(!is.finite(log_prior_proposed))) {
          cat("Chain", chain, "Iteration", i, ": Proposed theta outside valid
              domain, rejecting proposal.\n")
          theta_chain[i, ] <- current_theta
          loglike_chain[i] <- current_loglike
          state_est_chain[[i]] <- current_state_est
          next
        }

        pf_proposed <- do.call(particle_filter, c(
          list(
            y = y,
            n = target_n,
            init_fn = init_fn_ssm,
            transition_fn = transition_fn_ssm,
            log_likelihood_fn = log_likelihood_fn_ssm,
            algorithm = algorithm,
            resample_fn = resample_fn
          ),
          as.list(proposed_theta),
          list(...)
        ))
        proposed_loglike <- pf_proposed$loglike

        log_prior_current <- sapply(seq_along(current_theta), function(j) {
          log_priors[[j]](current_theta[j])
        })
        log_accept_ratio <- (sum(log_prior_proposed) + proposed_loglike) -
          (sum(log_prior_current) + current_loglike)

        if (log(stats::runif(1)) < log_accept_ratio) {
          current_theta <- proposed_theta
          current_loglike <- proposed_loglike
          current_state_est <- pf_proposed$state_est
        }

        theta_chain[i, ] <- current_theta
        loglike_chain[i] <- current_loglike
        state_est_chain[[i]] <- current_state_est
      }
    } else {
      for (i in 2:m) {
        valid_theta <- FALSE
        while (!valid_theta) {
          proposed_theta <- numeric(length(current_theta))
          for (j in seq_along(current_theta)) {
            if (param_transform[j] == "log") {
              # Propose on the log scale and transform back.
              log_theta <- log(current_theta[j]) + rnorm(
                1,
                mean = 0,
                sd = sqrt(proposal_cov[j, j])
              )
              proposed_theta[j] <- exp(log_theta)
            } else {
              proposed_theta[j] <- current_theta[j] + rnorm(
                1,
                mean = 0,
                sd = sqrt(proposal_cov[j, j])
              )
            }
          }
          # Compute the log-Jacobian adjustment for the proposed state.
          log_jacobian_proposed <- sum(
            sapply(seq_along(proposed_theta), function(j) {
              if (param_transform[j] == "log") {
                -log(proposed_theta[j])
              } else {
                0
              }
            }))
          log_prior_proposed <- sapply(seq_along(proposed_theta), function(j) {
            log_priors[[j]](proposed_theta[j])
          })
          if (all(is.finite(log_prior_proposed))) {
            valid_theta <- TRUE
          } else {
            cat("Chain", chain, "Iteration", i, ": Proposed theta outside
                valid domain, retrying...\n")
          }
        }

        pf_proposed <- do.call(particle_filter, c(
          list(
            y = y,
            n = target_n,
            init_fn = init_fn_ssm,
            transition_fn = transition_fn_ssm,
            log_likelihood_fn = log_likelihood_fn_ssm,
            algorithm = algorithm,
            resample_fn = resample_fn
          ),
          as.list(proposed_theta),
          list(...)
        ))
        proposed_loglike <- pf_proposed$loglike

        log_prior_current <- sapply(seq_along(current_theta), function(j) {
          log_priors[[j]](current_theta[j])
        })

        # Note: Add the Jacobian for the proposed state.
        log_num <- sum(log_prior_proposed) + proposed_loglike +
          log_jacobian_proposed
        log_denom <- sum(log_prior_current) + current_loglike
        log_accept_ratio <- log_num - log_denom

        if (log(stats::runif(1)) < log_accept_ratio) {
          current_theta <- proposed_theta
          current_loglike <- proposed_loglike
          current_state_est <- pf_proposed$state_est
        }

        theta_chain[i, ] <- current_theta
        loglike_chain[i] <- current_loglike
        state_est_chain[[i]] <- current_state_est
      }
    }

    theta_chains[[chain]] <- theta_chain
    loglike_chains[[chain]] <- loglike_chain
    state_est_chains[[chain]] <- state_est_chain
  }

  # ---------------------------
  # Step 3: Discard burn-in samples and compute latent state estimate.
  # ---------------------------
  theta_chain_post <- lapply(
    theta_chains,
    function(chain) chain[(burn_in + 1):m, , drop = FALSE]
  )
  loglike_chain_post <- lapply(
    loglike_chains,
    function(chain) chain[(burn_in + 1):m]
  )
  state_est_chain_post <- lapply(
    state_est_chains, function(chain) chain[(burn_in + 1):m]
  )

  # Combine latent state estimates from all chains and compute the column means:
  all_state_estimates <- do.call(
    rbind,
    unlist(state_est_chain_post, recursive = FALSE)
  )
  latent_state_estimate <- colMeans(all_state_estimates)

  return(list(
    theta_chain = theta_chain_post,
    loglike_chain = loglike_chain_post,
    latent_state_chain = state_est_chain_post,
    latent_state_estimate = latent_state_estimate
  ))
}
