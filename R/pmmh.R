#' Create Tuning Control Parameters
#'
#' This function creates a list of tuning parameters used by the pmmh function.
#'
#' @param pilot_proposal_sd Standard deviation for pilot proposals. Default is
#' 0.1.
#' @param pilot_n Number of pilot particles for particle filter. Default is 100.
#' @param pilot_m Number of iterations for MCMC. Default is 2000.
#' @param pilot_target_var The target variance for the posterior log-likelihood
#' evaluated at estimated posterior mean. Default is 1.
#' @param pilot_burn_in Number of burn-in iterations for MCMC. Default is 1000.
#' @param pilot_reps Number of times a particle filter is run. Default is 10.
#' @param pilot_algorithm The algorithm used for the pilot particle filter.
#' Default is "SISAR".
#' @param pilot_resample_fn The resampling function used for the pilot particle
#' filter. Default is "stratified".
#'
#' @return A list of tuning control parameters.
#' @export
default_tune_control <- function(
  pilot_proposal_sd = 0.1, pilot_n = 100, pilot_m = 2000,
  pilot_target_var = 1, pilot_burn_in = 1000, pilot_reps = 10,
  pilot_algorithm = c("SISAR", "SISR", "SIS"),
  pilot_resample_fn = c("stratified", "systematic", "multinomial")
) {
  if (!is.numeric(pilot_proposal_sd) || pilot_proposal_sd <= 0) {
    stop("pilot_proposal_sd must be a positive numeric value.")
  }
  if (!is.numeric(pilot_n) || pilot_n <= 0) {
    stop("pilot_n must be a positive numeric value.")
  }
  if (!is.numeric(pilot_m) || pilot_m <= 0) {
    stop("pilot_m must be a positive numeric value.")
  }
  if (!is.numeric(pilot_target_var) || pilot_target_var <= 0) {
    stop("pilot_target_var must be a positive numeric value.")
  }
  if (!is.numeric(pilot_burn_in) || pilot_burn_in <= 0) {
    stop("pilot_burn_in must be a positive numeric value.")
  }
  pilot_algorithm <- match.arg(pilot_algorithm)
  pilot_resample_fn <- match.arg(pilot_resample_fn)
  list(
    pilot_proposal_sd = pilot_proposal_sd,
    pilot_n = pilot_n,
    pilot_m = pilot_m,
    target_var = pilot_target_var,
    pilot_burn_in = pilot_burn_in,
    pilot_reps = pilot_reps,
    pilot_algorithm = pilot_algorithm,
    pilot_resample_fn = pilot_resample_fn
  )
}

#' Particle Marginal Metropolis-Hastings (PMMH) for State-Space Models
#'
#' This function implements a Particle Marginal Metropolis-Hastings (PMMH)
#' algorithm to perform Bayesian inference in state-space models. It first
#' runs a pilot chain to tune the proposal distribution and the number of
#' particles for the particle filter, and then runs the main PMMH chain.
#'
#' @param y A numeric vector of observations.
#' @param m An integer specifying the total number of MCMC iterations.
#' @param init_fn_ssm A function to initialize the state-space model.
#' @param transition_fn_ssm A function that defines the state transition of the
#' state-space model.
#' @param log_likelihood_fn_ssm A function that calculates the log-likelihood
#' for the state-space model given latent states.
#' @param log_priors A list of functions for computing the log-prior of each
#' parameter.
#' @param init_params A vector of initial parameter values.
#' @param burn_in An integer indicating the number of initial MCMC iterations
#' to discard as burn-in.
#' @param num_chains An integer specifying the number of PMMH chains to run.
#' @param algorithm A character string specifying the particle filtering
#' algorithm to use. Must be one of \code{"SISAR"}, \code{"SISR"}, or
#' \code{"SIS"}. Defaults to \code{"SISAR"}.
#' @param resample_fn A character string specifying the resampling method.
#' Must be one of \code{"stratified"}, \code{"systematic"}, or
#' \code{"multinomial"}. Defaults to \code{"stratified"}.
#' @param param_transform An optional character vector that specifies the
#' transformation applied to each parameter. Currently supports
#' \code{"log"} and \code{"identity"}. If \code{NULL}, the \code{"identity"}
#' transformation is used for all parameters.
#' @param tune_control A list generated by \code{\link{default_tune_control}}
#' containing tuning parameters for the pilot chain, such as \code{pilot_m},
#' \code{pilot_n}, \code{pilot_reps}, \code{pilot_proposal_sd},
#' \code{pilot_algorithm}, and \code{pilot_resample_fn}.
#' @param ... Additional arguments passed to the state-space model functions
#' and the particle filter.
#'
#' @details The PMMH algorithm proceeds in three main steps:
#' \enumerate{
#'   \item \strong{Pilot Chain:} A pilot particle chain is run using the
#'   settings provided in \code{tune_control} to obtain initial estimates for
#'   the parameter vector, its covariance, and the required number of particles.
#'   \item \strong{Main MCMC Chain:} The main PMMH chain is executed for
#'   \code{m} iterations using the tuned settings. The proposal step may
#'   apply a log or identity transformation to each parameter based on the
#'   \code{param_transform} argument.
#'   \item \strong{Post-Processing:} After discarding the burn-in samples,
#'   the latent state estimates from the remaining iterations are combined to
#'   compute a final latent state estimate as the column means of the latent
#'   state matrix.
#' }
#'
#' @return A list containing:
#' \describe{
#'   \item{\code{theta_chain}}{A matrix of post burn-in parameter samples.}
#'   \item{\code{latent_state_chain}}{A list of latent state estimates from
#'   each post burn-in iteration.}
#'   \item{\code{latent_state_estimate}}{A vector of the final latent state
#'   estimate, computed as the column means of the latent state matrix.}
#' }
#'
#' @examples
#' init_fn_ssm <- function(particles) {
#'   stats::rnorm(particles, mean = 0, sd = 1)
#' }
#' transition_fn_ssm <- function(particles, phi, sigma_x) {
#'   phi * particles + sin(particles) +
#'   stats::rnorm(length(particles), mean = 0, sd = sigma_x)
#' }
#' log_likelihood_fn_ssm <- function(y, particles, sigma_y) {
#'   stats::dnorm(y, mean = particles, sd = sigma_y, log = TRUE)
#' }
#' log_prior_phi <- function(phi) {
#'   stats::dnorm(phi, mean = 0, sd = 1, log = TRUE)
#' }
#' log_prior_sigma_x <- function(sigma) {
#'   stats::dexp(sigma, rate = 1, log = TRUE)
#' }
#' log_prior_sigma_y <- function(sigma) {
#'   stats::dexp(sigma, rate = 1, log = TRUE)
#' }
#' log_priors <- list(
#'   phi = log_prior_phi,
#'   sigma_x = log_prior_sigma_x,
#'   sigma_y = log_prior_sigma_y
#' )
#' # Generate data
#' x <- numeric(50)
#' y <- numeric(50)
#' x[1] <- rnorm(1, mean = 0, sd = 1)
#' y[1] <- rnorm(1, mean = x[1], sd = 0.5)
#' for (t in 2:50) {
#'   x[t] <- 0.8 * x[t - 1] + sin(x[t - 1]) + rnorm(1, mean = 0, sd = 1)
#'   y[t] <- x[t] + rnorm(1, mean = 0, sd = 0.5)
#' }
#' # Should use much higher MCMC iterations in practice (m)
#' pmmh_result <- pmmh(
#'   y = y,
#'   m = 500,
#'   init_fn_ssm = init_fn_ssm,
#'   transition_fn_ssm = transition_fn_ssm,
#'   log_likelihood_fn_ssm = log_likelihood_fn_ssm,
#'   log_priors = log_priors,
#'   init_params = c(phi = 0.8, sigma_x = 1, sigma_y = 0.5),
#'   burn_in = 100,
#'   num_chains = 1,
#'   param_transform = c("identity", "log", "log"),
#'   tune_control = default_tune_control(pilot_m = 100, pilot_burn_in = 50)
#' )
#' @export
pmmh <- function(y, m, init_fn_ssm, transition_fn_ssm, log_likelihood_fn_ssm,
                 log_priors, init_params, burn_in, num_chains = 4,
                 algorithm = c("SISAR", "SISR", "SIS"),
                 resample_fn = c("stratified", "systematic", "multinomial"),
                 param_transform = NULL,
                 tune_control = default_tune_control(),
                 ...) {

  # ---------------------------
  # Input validation
  # ---------------------------
  if (!is.numeric(y)) stop("y must be a numeric vector")
  if (!is.numeric(m) || m <= 0) stop("m must be a positive integer")
  if (!is.numeric(burn_in) || burn_in <= 0) {
    stop("burn_in must be a positive integer")
  }
  if (burn_in >= m) {
    stop("burn_in must be smaller than the number of MCMC iterations (m)")
  }
  if (!is.numeric(num_chains) || num_chains <= 0) {
    stop("num_chains must be a positive integer")
  }

  .check_params_match(init_fn_ssm, transition_fn_ssm, log_likelihood_fn_ssm,
                      init_params, log_priors)

  # Check if y is an argument in log_likelihood_fn_ssm
  if (!"y" %in% names(formals(log_likelihood_fn_ssm))) {
    stop("log_likelihood_fn_ssm must take 'y' as an argument")
  }


  algorithm <- match.arg(algorithm)
  resample_fn <- match.arg(resample_fn)

  n_params <- length(init_params)
  if (is.null(param_transform)) {
    param_transform <- rep("identity", n_params)
  } else {
    if (length(param_transform) != n_params) {
      stop("param_transform must have the same length as init_params")
    }
    valid_transforms <- c("log", "identity")
    invalid <- !param_transform %in% valid_transforms
    if (any(invalid)) {
      warning("Only 'log' and 'identity' transformations are supported.
              Using 'identity' for invalid entries.")
      param_transform[invalid] <- "identity"
    }
  }

  # Add ... as arg if user didn't
  has_dots <- function(fun) {
    "..." %in% names(formals(fun))
  }

  if (!has_dots(init_fn_ssm)) {
    formals(init_fn_ssm) <- c(formals(init_fn_ssm), alist(... = ))
  }
  if (!has_dots(transition_fn_ssm)) {
    formals(transition_fn_ssm) <- c(formals(transition_fn_ssm), alist(... = ))
  }
  if (!has_dots(log_likelihood_fn_ssm)) {
    formals(log_likelihood_fn_ssm) <- c(formals(log_likelihood_fn_ssm),
                                        alist(... = ))
  }

  tune_control$pilot_proposal_sd <- rep(tune_control$pilot_proposal_sd,
                                        length.out = n_params)

  # ---------------------------
  # Helper functions for parameter transformation
  # ---------------------------
  transform_params <- function(theta, transform) {
    # Applies the specified transformation to each parameter.
    sapply(seq_along(theta), function(j) {
      if (transform[j] == "log") log(theta[j]) else theta[j]
    })
  }

  back_transform_params <- function(theta_trans, transform) {
    # Inverse transforms parameters back to the original scale.
    sapply(seq_along(theta_trans), function(j) {
      if (transform[j] == "log") exp(theta_trans[j]) else theta_trans[j]
    })
  }

  compute_jacobian <- function(theta, transform) {
    # For a log transform, |dx/dz| = x, so log|dx/dz| = log(x); otherwise zero.
    sum(sapply(seq_along(theta), function(j) {
      if (transform[j] == "log") log(theta[j]) else 0
    }))
  }

  # ---------------------------
  # Step 1: Run the pilot (particle) chain for tuning
  # ---------------------------
  pilot_chain <- .run_pilot_chain(
    y = y,
    pilot_m = tune_control$pilot_m,
    pilot_n = tune_control$pilot_n,
    pilot_reps = tune_control$pilot_reps,
    init_fn_ssm = init_fn_ssm,
    transition_fn_ssm = transition_fn_ssm,
    log_likelihood_fn_ssm = log_likelihood_fn_ssm,
    log_priors = log_priors,
    proposal_sd = tune_control$pilot_proposal_sd,
    init_params = init_params,
    algorithm = tune_control$pilot_algorithm,
    resample_fn = tune_control$pilot_resample_fn,
    param_transform = param_transform,
    ...
  )

  init_theta <- pilot_chain$pilot_theta_mean
  proposal_cov <- pilot_chain$pilot_theta_cov
  target_n <- pilot_chain$target_n

  # Precompute the transformed proposal covariance:
  # For log-transformed parameters, the scaling is done using the pilot
  # estimates.
  scale_vec <- sapply(seq_along(init_theta), function(j) {
    if (param_transform[j] == "log") init_theta[j] else 1
  })
  proposal_cov_trans <- diag(1 / scale_vec) %*% proposal_cov %*%
    diag(1 / scale_vec)

  message("Running particle MCMC chains with tuned settings...")

  # ---------------------------
  # Step 2: Run the PMMH chains using the tuned settings
  # ---------------------------
  theta_chains <- vector("list", num_chains)
  state_est_chains <- vector("list", num_chains)

  for (chain in 1:num_chains) {
    message("Running chain ", chain, "...")
    current_theta <- init_theta
    theta_chain <- matrix(NA, nrow = m, ncol = n_params)
    colnames(theta_chain) <- names(current_theta)
    state_est_chain <- vector("list", m)

    # Evaluate the particle filter at the initial parameter value.
    pf_result <- do.call(particle_filter, c(
      list(
        y = y,
        n = target_n,
        init_fn = init_fn_ssm,
        transition_fn = transition_fn_ssm,
        log_likelihood_fn = log_likelihood_fn_ssm,
        algorithm = algorithm,
        resample_fn = resample_fn
      ),
      as.list(current_theta),
      list(...)
    ))
    current_loglike <- pf_result$loglike
    current_state_est <- pf_result$state_est

    theta_chain[1, ] <- current_theta
    state_est_chain[[1]] <- current_state_est

    for (i in 2:m) {
      # --- Propose in the transformed space ---
      current_theta_trans <- transform_params(current_theta, param_transform)
      proposed_theta_trans <- MASS::mvrnorm(n = 1, mu = current_theta_trans,
                                            Sigma = proposal_cov_trans)
      proposed_theta <- back_transform_params(proposed_theta_trans,
                                              param_transform)

      # --- Check the validity of proposed parameters ---
      log_prior_proposed <- sapply(seq_along(proposed_theta), function(j) {
        log_priors[[j]](proposed_theta[j])
      })
      if (any(!is.finite(log_prior_proposed))) {
        theta_chain[i, ] <- current_theta
        state_est_chain[[i]] <- current_state_est
        next
      }

      # Run the particle filter for the proposed parameters.
      pf_proposed <- do.call(particle_filter, c(
        list(
          y = y,
          n = target_n,
          init_fn = init_fn_ssm,
          transition_fn = transition_fn_ssm,
          log_likelihood_fn = log_likelihood_fn_ssm,
          algorithm = algorithm,
          resample_fn = resample_fn
        ),
        as.list(proposed_theta),
        list(...)
      ))
      proposed_loglike <- pf_proposed$loglike

      # --- Compute the Jacobian adjustments ---
      log_jacobian_proposed <- compute_jacobian(proposed_theta, param_transform)
      log_jacobian_current  <- compute_jacobian(current_theta, param_transform)

      # --- Compute the acceptance ratio ---
      log_prior_current <- sapply(seq_along(current_theta), function(j) {
        log_priors[[j]](current_theta[j])
      })
      log_accept_num <- (proposed_loglike + sum(log_prior_proposed) +
                           log_jacobian_proposed)
      log_accept_denom <- (current_loglike + sum(log_prior_current) +
                             log_jacobian_current)
      log_accept_ratio <- log_accept_num - log_accept_denom

      if (log(runif(1)) < log_accept_ratio) {
        current_theta <- proposed_theta
        current_loglike <- proposed_loglike
        current_state_est <- pf_proposed$state_est
      }

      theta_chain[i, ] <- current_theta
      state_est_chain[[i]] <- current_state_est
    }

    theta_chains[[chain]] <- theta_chain
    state_est_chains[[chain]] <- state_est_chain
  }

  # ---------------------------
  # Step 3: Post-processing - discard burn-in and compute latent state estimate.
  # ---------------------------
  theta_chain_post <- lapply(
    theta_chains, function(chain) chain[(burn_in + 1):m, , drop = FALSE]
  )
  state_est_chain_post <- lapply(
    state_est_chains, function(chain) chain[(burn_in + 1):m]
  )

  # Combine latent state estimates from all chains and compute column means.
  all_state_estimates <- do.call(
    rbind, unlist(state_est_chain_post, recursive = FALSE)
  )
  latent_state_estimate <- colMeans(all_state_estimates)

  # ---------------------------
  # Step 4: Compute diagnostics (ESS and Rhat) for each parameter.
  # ---------------------------

  n_params <- ncol(theta_chain_post[[1]])
  diagnostics <- list()
  for (j in 1:n_params) {
    # Combine the j-th parameter across all chains into a matrix:
    # Each column corresponds to one chain.
    param_matrix <- sapply(theta_chain_post, function(chain) chain[, j])
    diagnostics[[ colnames(theta_chain_post[[1]])[j] ]] <- list(
      ess = ess(param_matrix),
      rhat = rhat(param_matrix)
    )
  }

  result <- list(
    theta_chain = theta_chain_post,   # MCMC samples of theta
    latent_state_chain = state_est_chain_post,  # Samples of latent states
    latent_state_estimate = latent_state_estimate, # Final state estimates
    diagnostics = diagnostics  # Convergence diagnostics (ESS, Rhat)
  )

  # Assign class
  class(result) <- "pmmh_output"

  return(result)
}

