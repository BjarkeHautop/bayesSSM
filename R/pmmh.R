#' Create Tuning Control Parameters
#'
#' This function creates a list of tuning parameters used by the pmmh function.
#'
#' @param pilot_proposal_sd Standard deviation for pilot proposals. Default is
#' 1.
#' @param pilot_n Number of pilot particles for particle filter. Default is 100.
#' @param pilot_m Number of iterations for MCMC. Default is 2000.
#' @param pilot_target_var The target variance for the posterior log-likelihood
#' evaluated at estimated posterior mean. Default is 1.
#' @param pilot_burn_in Number of burn-in iterations for MCMC. Default is 1000.
#' @param pilot_reps Number of times a particle filter is run. Default is 10.
#' @param pilot_algorithm The algorithm used for the pilot particle filter.
#' Default is "SISAR".
#' @param pilot_resample_fn The resampling function used for the pilot particle
#' filter. Default is "stratified".
#'
#' @return A list of tuning control parameters.
#' @export
default_tune_control <- function(
    pilot_proposal_sd = 1, pilot_n = 100, pilot_m = 2000,
    pilot_target_var = 1, pilot_burn_in = 1000, pilot_reps = 10,
    pilot_algorithm = c("SISAR", "SISR", "SIS"),
    pilot_resample_fn = c("stratified", "systematic", "multinomial")) {
  if (!is.numeric(pilot_proposal_sd) || pilot_proposal_sd <= 0) {
    stop("pilot_proposal_sd must be a positive numeric value.")
  }
  if (!is.numeric(pilot_n) || pilot_n <= 0) {
    stop("pilot_n must be a positive numeric value.")
  }
  if (!is.numeric(pilot_m) || pilot_m <= 0) {
    stop("pilot_m must be a positive numeric value.")
  }
  if (!is.numeric(pilot_target_var) || pilot_target_var <= 0) {
    stop("pilot_target_var must be a positive numeric value.")
  }
  if (!is.numeric(pilot_burn_in) || pilot_burn_in <= 0) {
    stop("pilot_burn_in must be a positive numeric value.")
  }
  pilot_algorithm <- match.arg(pilot_algorithm)
  pilot_resample_fn <- match.arg(pilot_resample_fn)
  list(
    pilot_proposal_sd = pilot_proposal_sd,
    pilot_n = pilot_n,
    pilot_m = pilot_m,
    target_var = pilot_target_var,
    pilot_burn_in = pilot_burn_in,
    pilot_reps = pilot_reps,
    pilot_algorithm = pilot_algorithm,
    pilot_resample_fn = pilot_resample_fn
  )
}

#' Particle Marginal Metropolis-Hastings (PMMH) for State-Space Models
#'
#' This function implements a Particle Marginal Metropolis-Hastings (PMMH)
#' algorithm to perform Bayesian inference in state-space models. It first
#' runs a pilot chain to tune the proposal distribution and the number of
#' particles for the particle filter, and then runs the main PMMH chain.
#'
#' @param y A numeric vector of observations.
#' @param m An integer specifying the total number of MCMC iterations.
#' @param init_fn_ssm A function to initialize the state-space model.
#' @param transition_fn_ssm A function that defines the state transition of the
#' state-space model.
#' @param log_likelihood_fn_ssm A function that calculates the log-likelihood
#' for the state-space model given latent states.
#' @param log_priors A list of functions for computing the log-prior of each
#' parameter.
#' @param init_params A vector of initial parameter values.
#' @param burn_in An integer indicating the number of initial MCMC iterations
#' to discard as burn-in.
#' @param num_chains An integer specifying the number of PMMH chains to run.
#' @param algorithm A character string specifying the particle filtering
#' algorithm to use. Must be one of \code{"SISAR"}, \code{"SISR"}, or
#' \code{"SIS"}. Defaults to \code{"SISAR"}.
#' @param resample_fn A character string specifying the resampling method.
#' Must be one of \code{"stratified"}, \code{"systematic"}, or
#' \code{"multinomial"}. Defaults to \code{"stratified"}.
#' @param param_transform An optional character vector that specifies the
#' transformation applied to each parameter. Currently supports
#' \code{"log"} and \code{"identity"}. If \code{NULL}, the \code{"identity"}
#' transformation is used for all parameters.
#' @param tune_control A list generated by \code{\link{default_tune_control}}
#' containing tuning parameters for the pilot chain, such as \code{pilot_m},
#' \code{pilot_n}, \code{pilot_reps}, \code{pilot_proposal_sd},
#' \code{pilot_algorithm}, and \code{pilot_resample_fn}.
#' @param verbose A logical value indicating whether to print information about
#' pilot_run tuning. Defaults to \code{FALSE}.
#' @param seed An optional integer to set the seed for reproducibility.
#'
#' @details The PMMH algorithm proceeds in two main steps:
#' \enumerate{
#'   \item \strong{Pilot Chain:} A pilot particle chain is run using the
#'   settings provided in \code{tune_control} to obtain initial estimates for
#'   the parameter vector, its covariance, and the number of particles for
#'   the Particle Filter.
#'   \item \strong{Main MCMC Chain:} The main PMMH chain is executed for
#'   \code{m} iterations using the tuned settings.
#' }
#'
#' @return A list containing:

#' \describe{
#'   \item{\code{theta_chain}}{A matrix of post burn-in parameter samples.}
#'   \item{\code{latent_state_chain}}{A list containg mean and variance
#'   of latent state estimates for each time step.}
#'   \item{\code{latent_state_estimate}}{diagnostics containing ESS and Rhat.}
#' }
#'
#' @export
#'
#' @examples
#' init_fn_ssm <- function(particles) {
#'   stats::rnorm(particles, mean = 0, sd = 1)
#' }
#' transition_fn_ssm <- function(particles, phi, sigma_x) {
#'   phi * particles + sin(particles) +
#'     stats::rnorm(length(particles), mean = 0, sd = sigma_x)
#' }
#' log_likelihood_fn_ssm <- function(y, particles, sigma_y) {
#'   stats::dnorm(y, mean = particles, sd = sigma_y, log = TRUE)
#' }
#' log_prior_phi <- function(phi) {
#'   stats::dnorm(phi, mean = 0, sd = 1, log = TRUE)
#' }
#' log_prior_sigma_x <- function(sigma) {
#'   stats::dexp(sigma, rate = 1, log = TRUE)
#' }
#' log_prior_sigma_y <- function(sigma) {
#'   stats::dexp(sigma, rate = 1, log = TRUE)
#' }
#' log_priors <- list(
#'   phi = log_prior_phi,
#'   sigma_x = log_prior_sigma_x,
#'   sigma_y = log_prior_sigma_y
#' )
#' # Generate data
#' t_val <- 20
#' x <- numeric(t_val)
#' y <- numeric(t_val)
#' x[1] <- rnorm(1, mean = 0, sd = 1)
#' y[1] <- rnorm(1, mean = x[1], sd = 0.5)
#' for (t in 2:t_val) {
#'   x[t] <- 0.8 * x[t - 1] + sin(x[t - 1]) + rnorm(1, mean = 0, sd = 1)
#'   y[t] <- x[t] + rnorm(1, mean = 0, sd = 0.5)
#' }
#' # Should use much higher MCMC iterations in practice (m)
#' pmmh_result <- pmmh(
#'   y = y,
#'   m = 1000,
#'   init_fn_ssm = init_fn_ssm,
#'   transition_fn_ssm = transition_fn_ssm,
#'   log_likelihood_fn_ssm = log_likelihood_fn_ssm,
#'   log_priors = log_priors,
#'   init_params = c(phi = 0.8, sigma_x = 1, sigma_y = 0.5),
#'   burn_in = 100,
#'   num_chains = 2,
#'   param_transform = list(
#'     phi = "identity",
#'     sigma_x = "log",
#'     sigma_y = "log"
#'   )
#' )
#' # Convergence warning is expected with such low MCMC iterations.
#'
pmmh <- function(y, m, init_fn_ssm, transition_fn_ssm, log_likelihood_fn_ssm,
         log_priors, init_params, burn_in, num_chains = 4,
         algorithm = c("SISAR", "SISR", "SIS"),
         resample_fn = c("stratified", "systematic", "multinomial"),
         param_transform = NULL,
         tune_control = default_tune_control(),
         verbose = FALSE,
         seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  # ---------------------------
  # Input validation
  # ---------------------------
  if (!is.numeric(y)) stop("y must be a numeric vector")
  if (!is.numeric(m) || m <= 0) stop("m must be a positive integer")
  if (!is.numeric(burn_in) || burn_in < 0) {
    stop("burn_in must be a positive integer")
  }
  if (burn_in >= m) {
    stop("burn_in must be smaller than the number of MCMC iterations (m)")
  }
  if (!is.numeric(num_chains) || num_chains <= 0) {
    stop("num_chains must be a positive integer")
  }

  .check_params_match(
    init_fn_ssm, transition_fn_ssm, log_likelihood_fn_ssm,
    init_params, log_priors
  )

  algorithm <- match.arg(algorithm)
  resample_fn <- match.arg(resample_fn)

  num_params <- length(init_params)
  # Ensure param_transform is set correctly.
  if (is.null(param_transform)) {
    param_transform <- rep("identity", num_params)
    names(param_transform) <- names(log_priors)
  } else {
    # If param_transform is provided as a list, convert it to a named vector.
    if (is.list(param_transform)) {
      if (!all(names(log_priors) %in% names(param_transform))) {
        stop(paste0("param_transform must include an entry for every parameter",
                    "in log_priors."))
      }
      # Order the transformation list to match the order of log_priors.
      param_transform <- unlist(param_transform[names(log_priors)])
    } else {
      # If it's a vector, ensure it is named (or warn the user).
      if (is.null(names(param_transform))) {
        warning(paste0("param_transform is not named. It is recommended to",
                       "supply a named list matching log_priors."))
      }
    }
    # Validate that only 'log' and 'identity' are used.
    invalid_transform <- which(!(param_transform %in% c("log", "identity")))
    if (length(invalid_transform) > 0) {
      warning(paste0(
        "Only 'log' and 'identity' transformations are supported.",
        " Using 'identity' for invalid entries."
      ))
      param_transform[invalid_transform] <- "identity"
    }
  }

  # Add ... as arg to functions if not present
  has_dots <- function(fun) {
    "..." %in% names(formals(fun))
  }

  if (!has_dots(init_fn_ssm)) {
    formals(init_fn_ssm) <- c(formals(init_fn_ssm), alist(... = ))
  }
  if (!has_dots(transition_fn_ssm)) {
    formals(transition_fn_ssm) <- c(formals(transition_fn_ssm), alist(... = ))
  }
  if (!has_dots(log_likelihood_fn_ssm)) {
    formals(log_likelihood_fn_ssm) <- c(
      formals(log_likelihood_fn_ssm),
      alist(... = )
    )
  }

  tune_control$pilot_proposal_sd <- rep(tune_control$pilot_proposal_sd,
                                        length.out = num_params
  )

  theta_chains <- vector("list", num_chains)
  state_est_chains <- vector("list", num_chains)

  for (chain in 1:num_chains) {
    message("Running chain ", chain, "...")

    # ---------------------------
    # Step 1: Run the pilot (particle) chain for tuning
    # ---------------------------
    message("Running pilot chain for tuning...")
    pilot_chain <- .run_pilot_chain(
      y = y,
      pilot_m = tune_control$pilot_m,
      pilot_n = tune_control$pilot_n,
      pilot_reps = tune_control$pilot_reps,
      init_fn_ssm = init_fn_ssm,
      transition_fn_ssm = transition_fn_ssm,
      log_likelihood_fn_ssm = log_likelihood_fn_ssm,
      log_priors = log_priors,
      proposal_sd = tune_control$pilot_proposal_sd,
      init_params = init_params,
      algorithm = tune_control$pilot_algorithm,
      resample_fn = tune_control$pilot_resample_fn,
      param_transform = param_transform,
      verbose = verbose
    )

    init_theta <- pilot_chain$pilot_theta_mean
    proposal_cov <- pilot_chain$pilot_theta_cov
    target_n <- pilot_chain$target_n

    # Precompute the transformed proposal covariance:
    # For log-transformed parameters, the scaling is done using the pilot
    # estimates.
    scale_vec <- sapply(seq_along(init_theta), function(j) {
      if (param_transform[j] == "log") init_theta[j] else 1
    })
    proposal_cov_trans <- diag(1 / scale_vec) %*% proposal_cov %*%
      diag(1 / scale_vec)

    # ---------------------------
    # Step 2: Run the PMMH chains using the tuned settings
    # ---------------------------

    message("Running particle MCMC chains with tuned settings...")



    current_theta <- init_theta
    theta_chain <- matrix(NA, nrow = m, ncol = num_params)
    colnames(theta_chain) <- names(current_theta)
    state_est_chain <- vector("list", m)

    # Evaluate the particle filter at the initial parameter value.
    pf_result <- do.call(particle_filter, c(
      list(
        y = y,
        n = target_n,
        init_fn = init_fn_ssm,
        transition_fn = transition_fn_ssm,
        log_likelihood_fn = log_likelihood_fn_ssm,
        algorithm = algorithm,
        resample_fn = resample_fn
      ),
      as.list(current_theta)
    ))
    current_loglike <- pf_result$loglike
    current_state_est <- pf_result$state_est

    theta_chain[1, ] <- current_theta
    state_est_chain[[1]] <- current_state_est

    for (i in 2:m) {
      # --- Propose in the transformed space ---
      current_theta_trans <- .transform_params(current_theta, param_transform)
      proposed_theta_trans <- MASS::mvrnorm(
        n = 1, mu = current_theta_trans,
        Sigma = proposal_cov_trans
      )
      proposed_theta <- .back_transform_params(
        proposed_theta_trans,
        param_transform
      )

      # --- Check the validity of proposed parameters ---
      log_prior_proposed <- sapply(seq_along(proposed_theta), function(j) {
        log_priors[[j]](proposed_theta[j])
      })
      if (any(!is.finite(log_prior_proposed))) {
        theta_chain[i, ] <- current_theta
        state_est_chain[[i]] <- current_state_est
        next
      }

      # Run the particle filter for the proposed parameters.
      pf_proposed <- do.call(particle_filter, c(
        list(
          y = y,
          n = target_n,
          init_fn = init_fn_ssm,
          transition_fn = transition_fn_ssm,
          log_likelihood_fn = log_likelihood_fn_ssm,
          algorithm = algorithm,
          resample_fn = resample_fn
        ),
        as.list(proposed_theta)
      ))
      proposed_loglike <- pf_proposed$loglike

      # --- Compute the Jacobian adjustments ---
      log_jacobian_proposed <- .compute_jacobian(
        theta = proposed_theta,
        transform = param_transform
      )

      log_jacobian_current <- .compute_jacobian(
        theta = current_theta,
        transform = param_transform
      )

      # --- Compute the acceptance ratio ---
      log_prior_current <- sapply(seq_along(current_theta), function(j) {
        log_priors[[j]](current_theta[j])
      })
      log_accept_num <- (proposed_loglike + sum(log_prior_proposed) +
                           log_jacobian_proposed)
      log_accept_denom <- (current_loglike + sum(log_prior_current) +
                             log_jacobian_current)
      log_accept_ratio <- log_accept_num - log_accept_denom

      if (log(stats::runif(1)) < log_accept_ratio) {
        current_theta <- proposed_theta
        current_loglike <- proposed_loglike
        current_state_est <- pf_proposed$state_est
      }

      theta_chain[i, ] <- current_theta
      state_est_chain[[i]] <- current_state_est
    }

    theta_chains[[chain]] <- theta_chain
    state_est_chains[[chain]] <- state_est_chain
  }

  # ---------------------------
  # Step 3: Post-processing - discard burn-in and compute latent state estimate.
  # ---------------------------
  theta_chain_post <- lapply(
    theta_chains, function(chain) chain[(burn_in + 1):m, , drop = FALSE]
  )
  state_est_chain_post <- lapply(
    state_est_chains, function(chain) chain[(burn_in + 1):m]
  )

  # Combine latent state estimates from all chains and compute column means.
  all_state_estimates <- do.call(
    rbind, unlist(state_est_chain_post, recursive = FALSE)
  )
  latent_state_estimate <- colMeans(all_state_estimates)
  latent_state_variance <- apply(all_state_estimates, 2, stats::var)


  # ---------------------------
  # Step 4: Compute diagnostics (ESS and Rhat) for each parameter.
  # ---------------------------

  separate_parameters <- function(theta_chain_post) {
    param_names <- colnames(theta_chain_post[[1]])
    result <- list()

    for (param in param_names) {
      # Extract and bind the values of the parameter for each chain
      param_combined <- do.call(
        cbind, lapply(seq_along(theta_chain_post), function(i) {
          chain_data <- theta_chain_post[[i]]
          param_data <- chain_data[, param, drop = FALSE]
          colnames(param_data) <- paste(param, "chain", i, sep = "_")

          param_data
        })
      )
      result[[param]] <- param_combined
    }

    result
  }

  theta_chain_per_param <- separate_parameters(theta_chain_post)
  param_ess <- list()
  param_rhat <- list()

  num_chains <- length(theta_chain_post)

  # Initialize flag for ESS message
  ess_message_shown <- FALSE

  for (param in names(theta_chain_per_param)) {
    param_chain <- theta_chain_per_param[[param]]

    if (num_chains > 1) {
      param_ess[[param]] <- ess(param_chain)
    } else {
      param_ess[[param]] <- NA
      # Show the message only once
      if (!ess_message_shown) {
        message(paste0(
          "ESS cannot be computed with only one chain. Run at least 2 chains."
        ))
        ess_message_shown <- TRUE
      }
    }

    param_rhat[[param]] <- rhat(param_chain)
  }

  # Convert chains to data frames
  theta_chain_post <- lapply(theta_chain_post, as.data.frame)
  result <- list(
    theta_chain = theta_chain_post,
    latent_state_estimate = list(
      mean = latent_state_estimate,
      var = latent_state_variance
    ),
    diagnostics = list(ess = param_ess, rhat = param_rhat)
  )

  # Assign class
  class(result) <- "pmmh_output"

  print(result)

  # If any ESS<400 print a warning
  if (any(sapply(param_ess, function(x) !is.na(x) && x < 400))) {
    warning(paste0(
      "Some ESS values are below 400, indicating poor mixing. ",
      "Consider running the chains for more iterations."
    ))
  }

  # If any Rhat>1.01 print a warning
  if (any(sapply(param_rhat, function(x) x > 1.01 && !is.na(x)))) {
    warning(paste0(
      "Some Rhat values are above 1.01, indicating that the chains ",
      "have not converged. Consider running the chains for more iterations ",
      "and/or increase burn_in."
    ))
  }

  # If any Rhat<0.99 Bug?
  if (any(sapply(param_rhat, function(x) x < 0.99 && !is.na(x)))) {
    message("Some Rhat values are below 0.99, please increase iterations or/and
          particles.
          If the issue persists it could be a bug,
          please submit an issue to Github.")
  }

  result
}
