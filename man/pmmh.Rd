% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmmh.R
\name{pmmh}
\alias{pmmh}
\title{Particle Marginal Metropolis-Hastings (PMMH) for State-Space Models}
\usage{
pmmh(
  y,
  m,
  init_fn_ssm,
  transition_fn_ssm,
  log_likelihood_fn_ssm,
  log_priors,
  init_params,
  burn_in,
  num_chains = 4,
  algorithm = c("SISAR", "SISR", "SIS"),
  resample_fn = c("stratified", "systematic", "multinomial"),
  param_transform = NULL,
  tune_control = tune_control(),
  ...
)
}
\arguments{
\item{y}{A numeric vector of observations.}

\item{m}{An integer specifying the total number of MCMC iterations.}

\item{init_fn_ssm}{A function to initialize the state-space model.}

\item{transition_fn_ssm}{A function that defines the state transition of the
state-space model.}

\item{log_likelihood_fn_ssm}{A function that calculates the log-likelihood
for the state-space model given latent states.}

\item{log_priors}{A list of functions for computing the log-prior of each
parameter.}

\item{init_params}{A vector of initial parameter values.}

\item{burn_in}{An integer indicating the number of initial MCMC iterations
to discard as burn-in.}

\item{num_chains}{An integer specifying the number of PMMH chains to run.}

\item{algorithm}{A character string specifying the particle filtering
algorithm to use. Must be one of \code{"SISAR"}, \code{"SISR"}, or
\code{"SIS"}. Defaults to \code{"SISAR"}.}

\item{resample_fn}{A character string specifying the resampling method.
Must be one of \code{"stratified"}, \code{"systematic"}, or
\code{"multinomial"}. Defaults to \code{"stratified"}.}

\item{param_transform}{An optional character vector that specifies the
transformation applied to each parameter. Currently supports
\code{"log"} and \code{"identity"}. If \code{NULL}, the \code{"identity"}
transformation is used for all parameters.}

\item{tune_control}{A list generated by \code{\link{tune_control}} containing
tuning parameters for the pilot chain, such as \code{pilot_m},
\code{pilot_n}, \code{pilot_reps}, \code{pilot_proposal_sd},
\code{pilot_algorithm}, and \code{pilot_resample_fn}.}

\item{...}{Additional arguments passed to the state-space model functions
and the particle filter.}
}
\value{
A list containing:
\describe{
  \item{\code{theta_chain}}{A matrix of post burn-in parameter samples.}
  \item{\code{loglike_chain}}{A numeric vector of post burn-in
  log-likelihood values.}
  \item{\code{latent_state_chain}}{A list of latent state estimates from
  each post burn-in iteration.}
  \item{\code{latent_state_estimate}}{A vector of the final latent state
  estimate, computed as the column means of the latent state matrix.}
}
}
\description{
This function implements a Particle Marginal Metropolis-Hastings (PMMH)
algorithm to perform Bayesian inference in state-space models. It first
runs a pilot chain to tune the proposal distribution and the number of
particles for the particle filter, and then runs the main PMMH chain.
}
\details{
The PMMH algorithm proceeds in three main steps:
\enumerate{
  \item \strong{Pilot Chain:} A pilot particle chain is run using the
  settings provided in \code{tune_control} to obtain initial estimates for
  the parameter vector, its covariance, and the required number of particles.
  \item \strong{Main MCMC Chain:} The main PMMH chain is executed for
  \code{m} iterations using the tuned settings. The proposal step may
  apply a log or identity transformation to each parameter based on the
  \code{param_transform} argument.
  \item \strong{Post-Processing:} After discarding the burn-in samples,
  the latent state estimates from the remaining iterations are combined to
  compute a final latent state estimate as the column means of the latent
  state matrix.
}
}
\examples{
\dontrun{
# Define dummy functions for the state-space model:
init_fn <- function() rnorm(1)
transition_fn <- function(x) x + rnorm(1)
log_likelihood_fn <- function(x, y) dnorm(y, mean = x, log = TRUE)
log_prior <- function(param) dnorm(param, log = TRUE)

# Generate some synthetic data:
y <- rnorm(100)
m <- 1000
init_params <- 0
burn_in <- 100

# Run the PMMH algorithm:
result <- pmmh(y, m, init_fn, transition_fn, log_likelihood_fn,
               log_priors = list(log_prior), init_params, burn_in)
}

}
